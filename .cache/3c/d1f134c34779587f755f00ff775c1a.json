{"id":"../node_modules/d3-geo/src/contains.js","dependencies":[{"name":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\package.json","includedInParent":true,"mtime":1701204570000},{"name":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\node_modules\\d3-geo\\package.json","includedInParent":true,"mtime":1710515717812},{"name":"./polygonContains.js","loc":{"line":1,"column":41,"index":41},"parent":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\node_modules\\d3-geo\\src\\contains.js","resolved":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\node_modules\\d3-geo\\src\\polygonContains.js"},{"name":"./distance.js","loc":{"line":2,"column":34,"index":99},"parent":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\node_modules\\d3-geo\\src\\contains.js","resolved":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\node_modules\\d3-geo\\src\\distance.js"},{"name":"./math.js","loc":{"line":3,"column":32,"index":148},"parent":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\node_modules\\d3-geo\\src\\contains.js","resolved":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\node_modules\\d3-geo\\src\\math.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\nvar _polygonContains = _interopRequireDefault(require(\"./polygonContains.js\"));\nvar _distance = _interopRequireDefault(require(\"./distance.js\"));\nvar _math = require(\"./math.js\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nvar containsObjectType = {\n  Feature: function (object, point) {\n    return containsGeometry(object.geometry, point);\n  },\n  FeatureCollection: function (object, point) {\n    var features = object.features,\n      i = -1,\n      n = features.length;\n    while (++i < n) if (containsGeometry(features[i].geometry, point)) return true;\n    return false;\n  }\n};\nvar containsGeometryType = {\n  Sphere: function () {\n    return true;\n  },\n  Point: function (object, point) {\n    return containsPoint(object.coordinates, point);\n  },\n  MultiPoint: function (object, point) {\n    var coordinates = object.coordinates,\n      i = -1,\n      n = coordinates.length;\n    while (++i < n) if (containsPoint(coordinates[i], point)) return true;\n    return false;\n  },\n  LineString: function (object, point) {\n    return containsLine(object.coordinates, point);\n  },\n  MultiLineString: function (object, point) {\n    var coordinates = object.coordinates,\n      i = -1,\n      n = coordinates.length;\n    while (++i < n) if (containsLine(coordinates[i], point)) return true;\n    return false;\n  },\n  Polygon: function (object, point) {\n    return containsPolygon(object.coordinates, point);\n  },\n  MultiPolygon: function (object, point) {\n    var coordinates = object.coordinates,\n      i = -1,\n      n = coordinates.length;\n    while (++i < n) if (containsPolygon(coordinates[i], point)) return true;\n    return false;\n  },\n  GeometryCollection: function (object, point) {\n    var geometries = object.geometries,\n      i = -1,\n      n = geometries.length;\n    while (++i < n) if (containsGeometry(geometries[i], point)) return true;\n    return false;\n  }\n};\nfunction containsGeometry(geometry, point) {\n  return geometry && containsGeometryType.hasOwnProperty(geometry.type) ? containsGeometryType[geometry.type](geometry, point) : false;\n}\nfunction containsPoint(coordinates, point) {\n  return (0, _distance.default)(coordinates, point) === 0;\n}\nfunction containsLine(coordinates, point) {\n  var ao, bo, ab;\n  for (var i = 0, n = coordinates.length; i < n; i++) {\n    bo = (0, _distance.default)(coordinates[i], point);\n    if (bo === 0) return true;\n    if (i > 0) {\n      ab = (0, _distance.default)(coordinates[i], coordinates[i - 1]);\n      if (ab > 0 && ao <= ab && bo <= ab && (ao + bo - ab) * (1 - Math.pow((ao - bo) / ab, 2)) < _math.epsilon2 * ab) return true;\n    }\n    ao = bo;\n  }\n  return false;\n}\nfunction containsPolygon(coordinates, point) {\n  return !!(0, _polygonContains.default)(coordinates.map(ringRadians), pointRadians(point));\n}\nfunction ringRadians(ring) {\n  return ring = ring.map(pointRadians), ring.pop(), ring;\n}\nfunction pointRadians(point) {\n  return [point[0] * _math.radians, point[1] * _math.radians];\n}\nfunction _default(object, point) {\n  return (object && containsObjectType.hasOwnProperty(object.type) ? containsObjectType[object.type] : containsGeometry)(object, point);\n}"},"sourceMaps":null,"error":null,"hash":"09094481ed46d30114b4b6ed50e79ae6","cacheData":{"env":{}}}