{"id":"../node_modules/@popperjs/core/lib/createPopper.js","dependencies":[{"name":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\package.json","includedInParent":true,"mtime":1715768641465},{"name":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\node_modules\\@popperjs\\core\\package.json","includedInParent":true,"mtime":1715088598035},{"name":"./dom-utils/getCompositeRect.js","loc":{"line":1,"column":29,"index":29},"parent":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\node_modules\\@popperjs\\core\\lib\\createPopper.js","resolved":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\node_modules\\@popperjs\\core\\lib\\dom-utils\\getCompositeRect.js"},{"name":"./dom-utils/getLayoutRect.js","loc":{"line":2,"column":26,"index":90},"parent":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\node_modules\\@popperjs\\core\\lib\\createPopper.js","resolved":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\node_modules\\@popperjs\\core\\lib\\dom-utils\\getLayoutRect.js"},{"name":"./dom-utils/listScrollParents.js","loc":{"line":3,"column":30,"index":152},"parent":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\node_modules\\@popperjs\\core\\lib\\createPopper.js","resolved":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\node_modules\\@popperjs\\core\\lib\\dom-utils\\listScrollParents.js"},{"name":"./dom-utils/getOffsetParent.js","loc":{"line":4,"column":28,"index":216},"parent":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\node_modules\\@popperjs\\core\\lib\\createPopper.js","resolved":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\node_modules\\@popperjs\\core\\lib\\dom-utils\\getOffsetParent.js"},{"name":"./utils/orderModifiers.js","loc":{"line":5,"column":27,"index":277},"parent":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\node_modules\\@popperjs\\core\\lib\\createPopper.js","resolved":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\node_modules\\@popperjs\\core\\lib\\utils\\orderModifiers.js"},{"name":"./utils/debounce.js","loc":{"line":6,"column":21,"index":327},"parent":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\node_modules\\@popperjs\\core\\lib\\createPopper.js","resolved":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\node_modules\\@popperjs\\core\\lib\\utils\\debounce.js"},{"name":"./utils/mergeByName.js","loc":{"line":7,"column":24,"index":374},"parent":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\node_modules\\@popperjs\\core\\lib\\createPopper.js","resolved":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\node_modules\\@popperjs\\core\\lib\\utils\\mergeByName.js"},{"name":"./utils/detectOverflow.js","loc":{"line":8,"column":27,"index":427},"parent":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\node_modules\\@popperjs\\core\\lib\\createPopper.js","resolved":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\node_modules\\@popperjs\\core\\lib\\utils\\detectOverflow.js"},{"name":"./dom-utils/instanceOf.js","loc":{"line":9,"column":26,"index":482},"parent":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\node_modules\\@popperjs\\core\\lib\\createPopper.js","resolved":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\node_modules\\@popperjs\\core\\lib\\dom-utils\\instanceOf.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createPopper = void 0;\nObject.defineProperty(exports, \"detectOverflow\", {\n  enumerable: true,\n  get: function () {\n    return _detectOverflow.default;\n  }\n});\nexports.popperGenerator = popperGenerator;\nvar _getCompositeRect = _interopRequireDefault(require(\"./dom-utils/getCompositeRect.js\"));\nvar _getLayoutRect = _interopRequireDefault(require(\"./dom-utils/getLayoutRect.js\"));\nvar _listScrollParents = _interopRequireDefault(require(\"./dom-utils/listScrollParents.js\"));\nvar _getOffsetParent = _interopRequireDefault(require(\"./dom-utils/getOffsetParent.js\"));\nvar _orderModifiers = _interopRequireDefault(require(\"./utils/orderModifiers.js\"));\nvar _debounce = _interopRequireDefault(require(\"./utils/debounce.js\"));\nvar _mergeByName = _interopRequireDefault(require(\"./utils/mergeByName.js\"));\nvar _detectOverflow = _interopRequireDefault(require(\"./utils/detectOverflow.js\"));\nvar _instanceOf = require(\"./dom-utils/instanceOf.js\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nvar DEFAULT_OPTIONS = {\n  placement: 'bottom',\n  modifiers: [],\n  strategy: 'absolute'\n};\nfunction areValidElements() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  return !args.some(function (element) {\n    return !(element && typeof element.getBoundingClientRect === 'function');\n  });\n}\nfunction popperGenerator(generatorOptions) {\n  if (generatorOptions === void 0) {\n    generatorOptions = {};\n  }\n  var _generatorOptions = generatorOptions,\n    _generatorOptions$def = _generatorOptions.defaultModifiers,\n    defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\n    _generatorOptions$def2 = _generatorOptions.defaultOptions,\n    defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n  return function createPopper(reference, popper, options) {\n    if (options === void 0) {\n      options = defaultOptions;\n    }\n    var state = {\n      placement: 'bottom',\n      orderedModifiers: [],\n      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\n      modifiersData: {},\n      elements: {\n        reference: reference,\n        popper: popper\n      },\n      attributes: {},\n      styles: {}\n    };\n    var effectCleanupFns = [];\n    var isDestroyed = false;\n    var instance = {\n      state: state,\n      setOptions: function setOptions(setOptionsAction) {\n        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;\n        cleanupModifierEffects();\n        state.options = Object.assign({}, defaultOptions, state.options, options);\n        state.scrollParents = {\n          reference: (0, _instanceOf.isElement)(reference) ? (0, _listScrollParents.default)(reference) : reference.contextElement ? (0, _listScrollParents.default)(reference.contextElement) : [],\n          popper: (0, _listScrollParents.default)(popper)\n        }; // Orders the modifiers based on their dependencies and `phase`\n        // properties\n\n        var orderedModifiers = (0, _orderModifiers.default)((0, _mergeByName.default)([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\n\n        state.orderedModifiers = orderedModifiers.filter(function (m) {\n          return m.enabled;\n        });\n        runModifierEffects();\n        return instance.update();\n      },\n      // Sync update – it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate: function forceUpdate() {\n        if (isDestroyed) {\n          return;\n        }\n        var _state$elements = state.elements,\n          reference = _state$elements.reference,\n          popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\n        // anymore\n\n        if (!areValidElements(reference, popper)) {\n          return;\n        } // Store the reference and popper rects to be read by modifiers\n\n        state.rects = {\n          reference: (0, _getCompositeRect.default)(reference, (0, _getOffsetParent.default)(popper), state.options.strategy === 'fixed'),\n          popper: (0, _getLayoutRect.default)(popper)\n        }; // Modifiers have the ability to reset the current update cycle. The\n        // most common use case for this is the `flip` modifier changing the\n        // placement, which then needs to re-run all the modifiers, because the\n        // logic was previously ran for the previous placement and is therefore\n        // stale/incorrect\n\n        state.reset = false;\n        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n        // is filled with the initial data specified by the modifier. This means\n        // it doesn't persist and is fresh on each update.\n        // To ensure persistent data, use `${name}#persistent`\n\n        state.orderedModifiers.forEach(function (modifier) {\n          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n        });\n        for (var index = 0; index < state.orderedModifiers.length; index++) {\n          if (state.reset === true) {\n            state.reset = false;\n            index = -1;\n            continue;\n          }\n          var _state$orderedModifie = state.orderedModifiers[index],\n            fn = _state$orderedModifie.fn,\n            _state$orderedModifie2 = _state$orderedModifie.options,\n            _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\n            name = _state$orderedModifie.name;\n          if (typeof fn === 'function') {\n            state = fn({\n              state: state,\n              options: _options,\n              name: name,\n              instance: instance\n            }) || state;\n          }\n        }\n      },\n      // Async and optimistically optimized update – it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: (0, _debounce.default)(function () {\n        return new Promise(function (resolve) {\n          instance.forceUpdate();\n          resolve(state);\n        });\n      }),\n      destroy: function destroy() {\n        cleanupModifierEffects();\n        isDestroyed = true;\n      }\n    };\n    if (!areValidElements(reference, popper)) {\n      return instance;\n    }\n    instance.setOptions(options).then(function (state) {\n      if (!isDestroyed && options.onFirstUpdate) {\n        options.onFirstUpdate(state);\n      }\n    }); // Modifiers have the ability to execute arbitrary code before the first\n    // update cycle runs. They will be executed in the same order as the update\n    // cycle. This is useful when a modifier adds some persistent data that\n    // other modifiers need to use, but the modifier is run after the dependent\n    // one.\n\n    function runModifierEffects() {\n      state.orderedModifiers.forEach(function (_ref) {\n        var name = _ref.name,\n          _ref$options = _ref.options,\n          options = _ref$options === void 0 ? {} : _ref$options,\n          effect = _ref.effect;\n        if (typeof effect === 'function') {\n          var cleanupFn = effect({\n            state: state,\n            name: name,\n            instance: instance,\n            options: options\n          });\n          var noopFn = function noopFn() {};\n          effectCleanupFns.push(cleanupFn || noopFn);\n        }\n      });\n    }\n    function cleanupModifierEffects() {\n      effectCleanupFns.forEach(function (fn) {\n        return fn();\n      });\n      effectCleanupFns = [];\n    }\n    return instance;\n  };\n}\nvar createPopper = exports.createPopper = /*#__PURE__*/popperGenerator(); // eslint-disable-next-line import/no-unused-modules"},"sourceMaps":null,"error":null,"hash":"b0442668c09b3b094a1a39bf34936c4a","cacheData":{"env":{}}}