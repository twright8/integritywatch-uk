{"id":"../node_modules/d3-hierarchy/src/treemap/squarify.js","dependencies":[{"name":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\package.json","includedInParent":true,"mtime":1701204570000},{"name":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\node_modules\\d3-hierarchy\\package.json","includedInParent":true,"mtime":1710515717879},{"name":"./dice.js","loc":{"line":1,"column":24,"index":24},"parent":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\node_modules\\d3-hierarchy\\src\\treemap\\squarify.js","resolved":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\node_modules\\d3-hierarchy\\src\\treemap\\dice.js"},{"name":"./slice.js","loc":{"line":2,"column":25,"index":62},"parent":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\node_modules\\d3-hierarchy\\src\\treemap\\squarify.js","resolved":"C:\\Users\\tom.wright\\PycharmProjects\\UK_meetings_app\\ukapp\\integritywatch-uk\\node_modules\\d3-hierarchy\\src\\treemap\\slice.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.phi = exports.default = void 0;\nexports.squarifyRatio = squarifyRatio;\nvar _dice = _interopRequireDefault(require(\"./dice.js\"));\nvar _slice = _interopRequireDefault(require(\"./slice.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nvar phi = exports.phi = (1 + Math.sqrt(5)) / 2;\nfunction squarifyRatio(ratio, parent, x0, y0, x1, y1) {\n  var rows = [],\n    nodes = parent.children,\n    row,\n    nodeValue,\n    i0 = 0,\n    i1 = 0,\n    n = nodes.length,\n    dx,\n    dy,\n    value = parent.value,\n    sumValue,\n    minValue,\n    maxValue,\n    newRatio,\n    minRatio,\n    alpha,\n    beta;\n  while (i0 < n) {\n    dx = x1 - x0, dy = y1 - y0;\n\n    // Find the next non-empty node.\n    do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);\n    minValue = maxValue = sumValue;\n    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);\n    beta = sumValue * sumValue * alpha;\n    minRatio = Math.max(maxValue / beta, beta / minValue);\n\n    // Keep adding nodes while the aspect ratio maintains or improves.\n    for (; i1 < n; ++i1) {\n      sumValue += nodeValue = nodes[i1].value;\n      if (nodeValue < minValue) minValue = nodeValue;\n      if (nodeValue > maxValue) maxValue = nodeValue;\n      beta = sumValue * sumValue * alpha;\n      newRatio = Math.max(maxValue / beta, beta / minValue);\n      if (newRatio > minRatio) {\n        sumValue -= nodeValue;\n        break;\n      }\n      minRatio = newRatio;\n    }\n\n    // Position and record the row orientation.\n    rows.push(row = {\n      value: sumValue,\n      dice: dx < dy,\n      children: nodes.slice(i0, i1)\n    });\n    if (row.dice) (0, _dice.default)(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);else (0, _slice.default)(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);\n    value -= sumValue, i0 = i1;\n  }\n  return rows;\n}\nvar _default = exports.default = function custom(ratio) {\n  function squarify(parent, x0, y0, x1, y1) {\n    squarifyRatio(ratio, parent, x0, y0, x1, y1);\n  }\n  squarify.ratio = function (x) {\n    return custom((x = +x) > 1 ? x : 1);\n  };\n  return squarify;\n}(phi);"},"sourceMaps":null,"error":null,"hash":"f43bdb01e8cce6a14aa559b3ea48c45b","cacheData":{"env":{}}}